package ca.ott.al.starmap.ui;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Polygon;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.event.ItemEvent;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.geom.GeneralPath;
import java.awt.geom.Point2D;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import javax.swing.JPanel;
import javax.swing.SwingUtilities;

import org.apache.log4j.Logger;

import ca.ott.al.starmap.core.GameCore;
import ca.ott.al.starmap.core.faction.Faction;
import ca.ott.al.starmap.core.map.InhabitedWorld;
import ca.ott.al.starmap.core.map.InhabitedWorld.PlanetLevel;
import ca.ott.al.starmap.core.map.StarMap;
import ca.ott.al.starmap.core.map.StarSystem;
import ca.ott.al.starmap.core.order.Order;
import ca.ott.al.starmap.core.order.OrderQueue;
import ca.ott.al.starmap.core.order.unit.move.AssaultOrder;
import ca.ott.al.starmap.core.order.unit.move.MoveOrder;
import ca.ott.al.starmap.core.transport.TransportFleet;
import ca.ott.al.starmap.core.unit.GarrisonForce;
import ca.ott.al.starmap.core.unit.MilitaryForce;
import ca.ott.al.starmap.core.unit.StarMapUnit;

public class StarMapPanel extends JPanel implements FactionAwareJPanel {

    /**
     * Generated by eclipse
     */
    private static final long serialVersionUID = -3772075949527966307L;

    private static Logger logger = Logger.getLogger(StarMapPanel.class.getName());

    private int panelWidth, panelHeight;

    // ISIF map control fields
    private int zoom;
    // private double mapCoordinateX, mapCoordinateY;
    private Point2D.Double mapCoordinate;
    private boolean dragCoordinatesFresh, mapIsDragged;
    private Point2D.Double lastDragCoordinate;

    private Faction selectedFaction;
    private UnitOrdersPanel parentPanel;

    // Fields for movement management data
    private boolean moveMode = false;
    private boolean assaultMode = false;
    private StarSystem sourceSystem = null;
    private Set<StarSystem> candidateDestinations;

    // Fields for drawing objects which can be reused
    BasicStroke stroke1f = new BasicStroke(1.0f);
    BasicStroke wideStroke2f = new BasicStroke(2.0f);
    BasicStroke wideStroke3f = new BasicStroke(3.0f);
    BasicStroke wideStroke4f = new BasicStroke(4.0f);
    BasicStroke strokeDash1f = new BasicStroke(1.0f, BasicStroke.CAP_BUTT, 0, BasicStroke.JOIN_ROUND, new float[] { 5f,
            2f }, 0);
    CompositeStroke compositeStroke = new CompositeStroke(wideStroke2f, stroke1f);
    BasicStroke assaultStroke = new BasicStroke(5.0f, BasicStroke.CAP_BUTT, 0, BasicStroke.JOIN_ROUND, new float[] { 3f,
            2f }, 0);
    
    Color moveBlue = new Color(123, 104, 238);
    Color assaultCrimson = new Color(220, 20, 60);

    /**
     * Default constructor.
     */
    public StarMapPanel(UnitOrdersPanel parent) {
        
        mapCoordinate = new Point2D.Double(0, 0);
        zoom = 100;
        parentPanel = parent;

        dragCoordinatesFresh = false;
        mapIsDragged = false;
        lastDragCoordinate = new Point2D.Double(0, 0);

        createEventListeners();

        candidateDestinations = new TreeSet<StarSystem>();
    }

    private Point2D.Double convertCoordinatesToStarMap(Point position) {
        // First, take note of the mapCoordinates of the panel's upper left
        // corner. From there, calculate the width and height of the panel in
        // light-years based on the appropriate zoom level
        double zoomFactorX = ((double) zoom / (double) 100);
        double mapCoordinateUpperLeftX = mapCoordinate.getX() - (panelWidth * 1 / zoomFactorX) / 2;

        double zoomFactorY = ((double) zoom / (double) 100);
        double mapCoordinateUpperLeftY = mapCoordinate.getY() + (panelHeight * 1 / zoomFactorY) / 2;

        double positionX = (double) position.x;
        double positionY = (double) position.y;

        double xComponent = positionX * 1 / zoomFactorX;
        double yComponent = positionY * 1 / zoomFactorY;

        double clickMapCoordX = mapCoordinateUpperLeftX + xComponent;
        double clickMapCoordY = mapCoordinateUpperLeftY - yComponent;
        return new Point2D.Double(clickMapCoordX, clickMapCoordY);
    }

    private void createEventListeners() {
        this.addMouseMotionListener(new MouseMotionListener() {

            @Override
            public synchronized void mouseDragged(MouseEvent e) {
                Point position = e.getPoint();
                logger.debug("Mouse dragged on starmap. panel position x: " + position.x + " y: " + position.y);
                mapIsDragged = true;
                // SwingUtilities.invokeLater(new Runnable() {
                // @Override
                // public void run() {
                // //parentPanel.adjustStarMapScrollBars(mapCoordinateX,
                // mapCoordinateY);
                // repaint();
                // }
                // });
                
//                Point2D.Double clickMapCoord = convertCoordinatesToStarMap(position);
//
//                double xDiff = clickMapCoord.x - lastDragCoordinate.getX();
//                double yDiff = clickMapCoord.y - lastDragCoordinate.getY();
//  
//                mapCoordinate.x -= xDiff;
//                mapCoordinate.y -= yDiff;
//
//                lastDragCoordinate.x = clickMapCoord.x;
//                lastDragCoordinate.y = clickMapCoord.y;
//                repaint();
            }

            @Override
            public void mouseMoved(MouseEvent e) {
                dragCoordinatesFresh = false;
            }

        });
        this.addMouseListener(new MouseListener() {

            @Override
            public void mouseReleased(MouseEvent e) {
                Point position = e.getPoint();
                logger.debug("Mouse dragged on starmap. panel position x: " + position.x + " y: " + position.y);

                Point2D.Double clickMapCoord = convertCoordinatesToStarMap(position);
                logger.debug("Mouse dragged on starmap. map position X: " + clickMapCoord.x + " Y: " + clickMapCoord.y);

                if (dragCoordinatesFresh && (lastDragCoordinate.getX() != clickMapCoord.x)
                        && (lastDragCoordinate.getY() != clickMapCoord.y) && mapIsDragged) {

                    double xDiff = clickMapCoord.x - lastDragCoordinate.getX();
                    double yDiff = clickMapCoord.y - lastDragCoordinate.getY();

                    mapCoordinate.x -= xDiff;
                    mapCoordinate.y -= yDiff;
                }

                dragCoordinatesFresh = false;
                mapIsDragged = false;

                repaint();
            }

            @Override
            public void mousePressed(MouseEvent e) {
                Point position = e.getPoint();
                logger.debug("Mouse pressed on starmap. panel position x: " + position.x + " y: " + position.y);

                Point2D.Double clickMapCoord = convertCoordinatesToStarMap(position);

                lastDragCoordinate.x = clickMapCoord.x;
                lastDragCoordinate.y = clickMapCoord.y;
                dragCoordinatesFresh = true;
            }

            @Override
            public void mouseExited(MouseEvent e) {
                // Auto-generated method stub

            }

            @Override
            public void mouseEntered(MouseEvent e) {
                // Auto-generated method stub

            }

            @Override
            public void mouseClicked(MouseEvent e) {
                logger.debug("Mouse click on starmap ");
                Point clickLocation = e.getPoint();

                Point2D.Double clickMapCoord = convertCoordinatesToStarMap(clickLocation);

                GameCore gameCore = GameCore.getGameCore();

                if (moveMode || assaultMode) {
                    // Select a system from a among those the unit could make a
                    // hop to
                    StarSystem selectedSystem = gameCore.getStarMap().getNearestStarSystem(clickMapCoord.x,
                            clickMapCoord.y);
                    if (candidateDestinations.contains(selectedSystem)) {
                        StarMapUnit unit = parentPanel.getUnitOrdersDetailPanel().getSelectedUnit();
                        // If the unit is a regular military force, it will need
                        // to secure transport
                        // from the faction's transport pool or pay the cost in
                        // resource points
                        TransportFleet tempFleet = null;
                        if (unit instanceof MilitaryForce) {
                            Faction unitOwnerFaction = unit.getOwner();
                            // For now, the TransportFleet is not populated.
                            // This step is to ensure that the cost of transport
                            // has been paid in TP or RP
                            tempFleet = unitOwnerFaction.getTransportPool().obtainTransportFleet(
                                    (MilitaryForce) unit);
                            // This handles the special case where no transport
                            // could be obtained
                            if (tempFleet == null) {
                                moveMode = false;
                                assaultMode = false;
                                return;
                            }
                        }
                        if (moveMode) {
                            MoveOrder moveOrder = new MoveOrder(sourceSystem, selectedSystem, tempFleet);
                            unit.addOrder(moveOrder);
                            parentPanel.getUnitOrdersDetailPanel().updateUnitOrders(unit);
                            parentPanel.updateOrderButtonsContext(unit);
                            parentPanel.updateTransportDetails();
                            
                            //The following line should force a refresh of the faction's economic data
                            InnerSphereInFlamesGui gui = InnerSphereInFlamesGui.getGui();
                            gui.updateFactionData(selectedFaction);
                        } else if (assaultMode) {
                            AssaultOrder assaultOrder = new AssaultOrder(sourceSystem, selectedSystem, tempFleet);
                            unit.addOrder(assaultOrder);
                            parentPanel.getUnitOrdersDetailPanel().updateUnitOrders(unit);
                            parentPanel.updateOrderButtonsContext(unit);
                            parentPanel.updateTransportDetails();
                            
                            //The following line should force a refresh of the faction's economic data
                            InnerSphereInFlamesGui gui = InnerSphereInFlamesGui.getGui();
                            gui.updateFactionData(selectedFaction);
                        }
                    } else {
                        // Ignore what the user has done for now...
                        // TODO: Warships will get transit points here
                    }

                    // Exit moveMode to false and repaint
                    moveMode = false;
                    assaultMode = false;
                } else {
                    StarSystem selectedSystem = gameCore.getStarMap().getNearestStarSystem(clickMapCoord.x,
                            clickMapCoord.y);

                    parentPanel.getUnitOrdersDetailPanel().setSelectedSystem(selectedSystem);
                    
                    //Switch the faction if that is appropriate
                    InhabitedWorld world = selectedSystem.getPrimaryPlanet();
                    if(world != null){
                        Faction faction = world.getControllingFaction();
                        //parentPanel.switchFaction(faction);
                        String factionName = faction.getFactionName();
                        InnerSphereInFlamesGui gui = InnerSphereInFlamesGui.getGui();
                        int anIndex = 0;
                        for(int i = 0; i< gui.factionComboBox.getItemCount(); i++){
                            String item = (String)gui.factionComboBox.getItemAt(i);
                            if(item.equals(factionName)){
                                anIndex = i;
                            }
                        }
                        gui.factionComboBox.setSelectedIndex(anIndex);
                    }
                }
                repaint();
            }
        });
    }

    // Methods for ISIF --------------------------------------------------------
    @Override
    public void switchFaction(Faction faction) {
        selectedFaction = faction;
        // TODO Control what the user can see for each faction
        // Note: The panel should only respond to stuff being done to the
        // selected faction
    }

    // Methods for update thread------------------------------------------------

    /* Wait for the JPanel to be added to the JFrame/JApplet before starting. */
    /* This method is called by Swing when setVisible() executes. */
    public void addNotify() {
        super.addNotify(); // creates the peer
    }

    // Rendering methods ------------------------------------------------------
    /**
     * Renders the panel
     * 
     * @param g
     */
    private void renderMap(Graphics g) {
        logger.debug("Rendering Starmap");
        g.setColor(Color.black);
        g.fillRect(0, 0, panelWidth, panelHeight);

        // draw game map elements

        // First, take note of the mapCoordinates of the panel's upper left
        // corner. From there, calculate the width and height of the panel in
        // light-years based on the appropriate zoom level
        double zoomFactor = ((double) zoom / (double) 100);
        double mapCoordinateLowerRightX = mapCoordinate.getX() + (panelWidth * 1 / zoomFactor) / 2;
        double mapCoordinateUpperLeftX = mapCoordinate.getX() - (panelWidth * 1 / zoomFactor) / 2;

        double mapCoordinateLowerRightY = mapCoordinate.getY() - (panelHeight * 1 / zoomFactor) / 2;
        double mapCoordinateUpperLeftY = mapCoordinate.getY() + (panelHeight * 1 / zoomFactor) / 2;

        GameCore gameCore = GameCore.getGameCore();

        // This is counter-intuitive but the movement lines need to be drawn
        // first
        StarMap starMap = gameCore.getStarMap();
        Collection<StarSystem> starSystems = starMap.getAllStarSystems();

        // Now that the lower right bound is known, go through the entire map
        for (StarSystem starSystem : starSystems) {

            // first draw the movement lines for regular units
            InhabitedWorld world = starSystem.getPrimaryPlanet();
            if (world != null) {
                Set<MilitaryForce> forces = world.getMilitaryForces();
                for (MilitaryForce force : forces) {
                    drawUnitMoveLines(g, force, mapCoordinateUpperLeftX, mapCoordinateUpperLeftY,
                            mapCoordinateLowerRightX, mapCoordinateLowerRightY, zoomFactor);
                }
            }

            // Draw the movement lines for units in space in the star system.
            // This includes warships

            Set<StarMapUnit> unitsInSpace = starSystem.getUnitsInSystem();
            if (!unitsInSpace.isEmpty()) {
                for (StarMapUnit unit : unitsInSpace) {
                    drawUnitMoveLines(g, unit, mapCoordinateUpperLeftX, mapCoordinateUpperLeftY,
                            mapCoordinateLowerRightX, mapCoordinateLowerRightY, zoomFactor);
                }
            }
            // double xCoord = starSystem.getPosition().getX();
            // double yCoord = starSystem.getPosition().getY();
            //
        }

        // drawAvailableDestinations(g,)
        drawAvailableDestinations(g, mapCoordinateUpperLeftX, mapCoordinateUpperLeftY, mapCoordinateLowerRightX,
                mapCoordinateLowerRightY, zoomFactor);

        g.setColor(Color.blue);
        for (StarSystem starSystem : starSystems) {
            double xCoord = starSystem.getPosition().getX();
            double yCoord = starSystem.getPosition().getY();

            if (xCoord >= mapCoordinateUpperLeftX && xCoord < mapCoordinateLowerRightX) {
                if (yCoord > mapCoordinateLowerRightY && yCoord <= mapCoordinateUpperLeftY) {
                    // Then we have a system that is in the viewing area. Draw
                    // system.
                    double xDrawingCoord = (xCoord - mapCoordinateUpperLeftX) * zoomFactor;
                    double yDrawingCoord = (mapCoordinateUpperLeftY - yCoord) * zoomFactor;

                    int xDraw = (int) Math.abs(xDrawingCoord);
                    int yDraw = (int) Math.abs(yDrawingCoord);

                    InhabitedWorld world = starSystem.getPrimaryPlanet();

                    // Flag for deciding whether to draw the system name
                    boolean drawSystemName = false;
                    boolean unitEngagedInconflict = false;
                    boolean systemContested = false;

                    if (world != null) {
                        g.setColor(world.getControllingFaction().getFactionColor());
                        g.drawLine(xDraw - 1, yDraw, xDraw + 1, yDraw);
                        g.drawLine(xDraw, yDraw - 1, xDraw, yDraw + 1);

                        // Decide if the planet is a capital and draw it's name
                        // at low zoom levels
                        PlanetLevel level = starSystem.getPrimaryPlanet().getPlanetLevel();
                        if ((zoom < 150) && (level == PlanetLevel.capital)) {
                            drawSystemName = true;
                        } else if ((zoom < 700) && (level != PlanetLevel.ordinary)) {
                            // Draw provincial capitals
                            drawSystemName = true;
                        } else if (zoom >= 700) {
                            // At high zoom, draw all the System names
                            drawSystemName = true;
                        }

                        // Draw a circle around the planet if non-garrison
                        // military units are stationed there
                        if (world != null) {
                            Set<MilitaryForce> forces = world.getMilitaryForces();
                            for (MilitaryForce force : forces) {
                                if (!(force instanceof GarrisonForce)) {
                                    if (zoom > 150) {
                                        g.drawOval(xDraw - 2, yDraw - 2, 4, 4);
                                        g.drawOval(xDraw - 3, yDraw - 3, 6, 6);
                                    }
                                }
                                if ((force.wasInvolvedInAerospaceCombatThisTurn()
                                        || force.wasInvolvedInGroundCombatThisTurn()) 
                                        ) {
                                    unitEngagedInconflict = true;
                                }
                            }
                            
                            Set<StarMapUnit> forcesOnPlanet = new HashSet<StarMapUnit>();
                            forcesOnPlanet.addAll(forces);
                           
                            Map<Faction,Set<StarMapUnit>> unitsByFaction = gameCore.parseUnitsByFaction(forcesOnPlanet);
                            gameCore.resolveAlliances(unitsByFaction);
                            if(unitsByFaction.size() > 1){
                                systemContested = true;
                            }
                        }

                        if (zoom >= 200) {
                            int iconSlot = 0;
                            // Factory
                            if (world.getFactorySize() > 0) {
                                drawSystemName = true;
                                drawFactory(g, xDraw, yDraw, iconSlot);
                                iconSlot++;
                            }

                            // Depot
                            if (world.getResourceDepot() > 0) {
                                drawSystemName = true;
                                drawDepot(g, xDraw, yDraw, iconSlot);
                                iconSlot++;
                            }

                            // Also draw something on Map if Warships present in
                            // system
                            if (!starSystem.getUnitsInSystem().isEmpty()) {
                                drawSystemName = true;
                                drawWarship(g, xDraw, yDraw, iconSlot);
                                iconSlot++;
                            }

                            // Fortification
                            if (world.getFortificationLevel() > 0) {
                                drawSystemName = true;
                                drawFortification(g, xDraw, yDraw, iconSlot);
                                iconSlot++;
                            }
                        }

                        // Draw names of planets with forces on them
                        if (zoom >= 400) {
                            if (world.getMilitaryForces().size() >= 2) {
                                drawSystemName = true;
                            }
                            if(world.hasNonGarrisonUnitsPresent()){
                                drawSystemName = true;
                            }
                        }

                        // Draw the system name if applicable
                        if (drawSystemName) {
                            g.drawString(starSystem.getName(), xDraw + 4, yDraw - 1);
                        }
                    } else {
                        // We have an empty star system acting as a transit
                        // point
                        g.setColor(Color.WHITE);
                        g.drawLine(xDraw - 1, yDraw, xDraw + 1, yDraw);
                        g.drawLine(xDraw, yDraw - 1, xDraw, yDraw + 1);

                        if (drawSystemName) {
                            String transitPointName = "Transit Point (" + Math.round(starSystem.getPosition().getX())
                                    + "." + Math.round(starSystem.getPosition().getY()) + ")";
                            g.drawString(transitPointName, xDraw + 4, yDraw - 1);
                        }
                    }

                    // Find out if there was combat in space this turn
                    // Note: Raiders will also show up here
                    if (!starSystem.getUnitsInSystem().isEmpty()) {

                        for (StarMapUnit unit : starSystem.getUnitsInSystem()) {
                            if (unit.wasInvolvedInAerospaceCombatThisTurn()) {
                                unitEngagedInconflict = true;
                            }
                        }
                    }
                    // Draw something to indicate conflict in the system
                    if (unitEngagedInconflict) {
                        drawSquare(g, xDraw, yDraw);
                    } else if(systemContested){
                        drawContest(g, xDraw, yDraw);
                    } 
                    if(starSystem.isConflictInSystem()){
                        drawClash(g, xDraw, yDraw, true);
                    }

                }
            }
        }// end: for star systems

        // Draw the selection reticle so the user knows where he clicked
        StarSystem selectedSystem = parentPanel.getUnitOrdersDetailPanel().getSelectedSystem();
        if (selectedSystem != null) {
            double xCoord = selectedSystem.getPosition().getX();
            double yCoord = selectedSystem.getPosition().getY();

            if (xCoord >= mapCoordinateUpperLeftX && xCoord < mapCoordinateLowerRightX) {
                if (yCoord > mapCoordinateLowerRightY && yCoord <= mapCoordinateUpperLeftY) {
                    // Then we have a system that is in the viewing area. Draw
                    // system.
                    double xDrawingCoord = (xCoord - mapCoordinateUpperLeftX) * zoomFactor;
                    double yDrawingCoord = (mapCoordinateUpperLeftY - yCoord) * zoomFactor;

                    int xDraw = (int) Math.abs(xDrawingCoord);
                    int yDraw = (int) Math.abs(yDrawingCoord);

                    g.setColor(Color.WHITE);
                    g.drawRect(xDraw - 4, yDraw - 4, 8, 8);

                }
            }
        }
    }

    private void drawAvailableDestinations(Graphics g, double mapCoordinateUpperLeftX, double mapCoordinateUpperLeftY,
            double mapCoordinateLowerRightX, double mapCoordinateLowerRightY, double zoomFactor) {
        Graphics2D g2 = (Graphics2D) g;

        // Draw the allowed movement lines to candidate destinations
        // if the panel is in moveMode
        if ((moveMode || assaultMode) && candidateDestinations != null && sourceSystem != null) {

            if (!candidateDestinations.isEmpty()) {
                double xCoord = sourceSystem.getPosition().getX();
                double yCoord = sourceSystem.getPosition().getY();

                if (xCoord >= mapCoordinateUpperLeftX && xCoord < mapCoordinateLowerRightX) {
                    if (yCoord > mapCoordinateLowerRightY && yCoord <= mapCoordinateUpperLeftY) {
                        // Then we have a source system that is in the viewing
                        // area.
                        double xDrawingCoord = (xCoord - mapCoordinateUpperLeftX) * zoomFactor;
                        double yDrawingCoord = (mapCoordinateUpperLeftY - yCoord) * zoomFactor;

                        int xDraw = (int) Math.abs(xDrawingCoord);
                        int yDraw = (int) Math.abs(yDrawingCoord);

                        for (StarSystem destination : candidateDestinations) {
                            double xDestCoord = destination.getPosition().getX();
                            double yDestCoord = destination.getPosition().getY();

                            if (xDestCoord >= mapCoordinateUpperLeftX && xDestCoord < mapCoordinateLowerRightX) {
                                if (yDestCoord > mapCoordinateLowerRightY && yDestCoord <= mapCoordinateUpperLeftY) {
                                    // Then we have a source system that is in
                                    // the viewing area.
                                    double xDestDrawingCoord = (xDestCoord - mapCoordinateUpperLeftX) * zoomFactor;
                                    double yDestDrawingCoord = (mapCoordinateUpperLeftY - yDestCoord) * zoomFactor;

                                    int xDestDraw = (int) Math.abs(xDestDrawingCoord);
                                    int yDestDraw = (int) Math.abs(yDestDrawingCoord);

                                    g2.setColor(Color.green);
                                    g2.setStroke(strokeDash1f);
                                    g2.drawLine(xDraw, yDraw, xDestDraw, yDestDraw);
                                    g2.setStroke(stroke1f);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     * Draw the move and assault lines on the map
     * 
     * @param g
     * @param force
     */
    private void drawUnitMoveLines(Graphics g, StarMapUnit force, double mapCoordinateUpperLeftX,
            double mapCoordinateUpperLeftY, double mapCoordinateLowerRightX, double mapCoordinateLowerRightY,
            double zoomFactor) {
        Graphics2D g2 = (Graphics2D) g;

        OrderQueue orderQueue = force.getOrders();
        List<Order> orders = orderQueue.getOrdersList();
        for (Order order : orders) {
            if (order instanceof MoveOrder) {
                StarSystem originSystem = ((MoveOrder) order).getOrigin();
                double originXCoord = originSystem.getPosition().getX();
                double originYCoord = originSystem.getPosition().getY();

                StarSystem destinationSystem = ((MoveOrder) order).getDestination();
                double destXCoord = destinationSystem.getPosition().getX();
                double destYCoord = destinationSystem.getPosition().getY();

                if ((originXCoord >= mapCoordinateUpperLeftX && originXCoord < mapCoordinateLowerRightX
                        && originYCoord > mapCoordinateLowerRightY && originYCoord <= mapCoordinateUpperLeftY)
                        && (destXCoord >= mapCoordinateUpperLeftX && destXCoord < mapCoordinateLowerRightX
                        && destYCoord > mapCoordinateLowerRightY && destYCoord <= mapCoordinateUpperLeftY)) {

                    double xOriginDrawingCoord = (originXCoord - mapCoordinateUpperLeftX) * zoomFactor;
                    double yOriginDrawingCoord = (mapCoordinateUpperLeftY - originYCoord) * zoomFactor;
                    int xOriginDraw = (int) Math.abs(xOriginDrawingCoord);
                    int yOriginDraw = (int) Math.abs(yOriginDrawingCoord);

                    double xDestDrawingCoord = (destXCoord - mapCoordinateUpperLeftX) * zoomFactor;
                    double yDestDrawingCoord = (mapCoordinateUpperLeftY - destYCoord) * zoomFactor;
                    int xDestDraw = (int) Math.abs(xDestDrawingCoord);
                    int yDestDraw = (int) Math.abs(yDestDrawingCoord);

                    // A type of blue
                    g2.setColor(moveBlue);
                    // g.drawLine(xOriginDraw, yOriginDraw, xDestDraw,
                    // yDestDraw);

                    g2.setStroke(wideStroke2f);
                    g2.drawLine(xOriginDraw, yOriginDraw, xDestDraw, yDestDraw);
                    g2.setStroke(stroke1f);
                }
            } else if (order instanceof AssaultOrder) {
                StarSystem originSystem = ((AssaultOrder) order).getOrigin();
                double originXCoord = originSystem.getPosition().getX();
                double originYCoord = originSystem.getPosition().getY();

                StarSystem destinationSystem = ((AssaultOrder) order).getDestination();
                double destXCoord = destinationSystem.getPosition().getX();
                double destYCoord = destinationSystem.getPosition().getY();
                if ((originXCoord >= mapCoordinateUpperLeftX && originXCoord < mapCoordinateLowerRightX
                        && originYCoord > mapCoordinateLowerRightY && originYCoord <= mapCoordinateUpperLeftY)
                        && (destXCoord >= mapCoordinateUpperLeftX && destXCoord < mapCoordinateLowerRightX
                        && destYCoord > mapCoordinateLowerRightY && destYCoord <= mapCoordinateUpperLeftY)) {

                    double xOriginDrawingCoord = (originXCoord - mapCoordinateUpperLeftX) * zoomFactor;
                    double yOriginDrawingCoord = (mapCoordinateUpperLeftY - originYCoord) * zoomFactor;
                    int xOriginDraw = (int) Math.abs(xOriginDrawingCoord);
                    int yOriginDraw = (int) Math.abs(yOriginDrawingCoord);

                    double xDestDrawingCoord = (destXCoord - mapCoordinateUpperLeftX) * zoomFactor;
                    double yDestDrawingCoord = (mapCoordinateUpperLeftY - destYCoord) * zoomFactor;
                    int xDestDraw = (int) Math.abs(xDestDrawingCoord);
                    int yDestDraw = (int) Math.abs(yDestDrawingCoord);

                    // A type of crimson
                    g2.setColor(assaultCrimson);
                    g2.setStroke(assaultStroke);
                    g2.drawLine(xOriginDraw, yOriginDraw, xDestDraw, yDestDraw);
                    g2.setStroke(stroke1f);
                }
            }
        }
    }
    
    private void drawSquare(Graphics g, int xDraw, int yDraw){
        Graphics2D g2 = (Graphics2D) g;
        g2.setColor(Color.green);
        
        g2.setStroke(wideStroke3f);
        
        GeneralPath square = new GeneralPath();
        square.moveTo(xDraw-6, yDraw+6);
        square.lineTo(xDraw+6, yDraw+6);
        square.lineTo(xDraw+6, yDraw-6);
        square.lineTo(xDraw-6, yDraw-6);
        square.closePath();
        g2.draw(square);
    }

    private void drawClash(Graphics g, int xDraw, int yDraw, boolean conflictInSystem) {
        Graphics2D g2 = (Graphics2D) g;
        List<Point> points = new ArrayList<Point>(17);
        points.add(new Point(-12, 0));
        points.add(new Point(-5, 2));
        points.add(new Point(-8, 8));
        points.add(new Point(-2, 5));
        points.add(new Point(0, 12));
        points.add(new Point(2, 5));
        points.add(new Point(8, 8));
        points.add(new Point(5, 2));
        points.add(new Point(12, 0));

        points.add(new Point(5, -2));
        points.add(new Point(8, -8));
        points.add(new Point(2, -5));
        points.add(new Point(0, -12));
        points.add(new Point(-2, -5));
        points.add(new Point(-8, -8));
        points.add(new Point(-5, -2));

        GeneralPath polygon = new GeneralPath(GeneralPath.WIND_EVEN_ODD, points.size());
        Point startPoint = points.get(0);
        polygon.moveTo(xDraw + startPoint.getX(), yDraw + startPoint.getY());
        for (Point point : points) {
            polygon.lineTo(xDraw + point.getX(), yDraw + point.getY());
        }
        polygon.closePath();

        if(conflictInSystem){
            g2.setColor(Color.yellow);
            g2.fill(polygon);
        }
        
        BasicStroke wideStroke = new BasicStroke(2.0f);
        g2.setStroke(wideStroke);
        g2.setColor(Color.red);
        g2.draw(polygon);

        BasicStroke stroke = new BasicStroke(1.0f);
        g2.setStroke(stroke);
    }
    
    private void drawContest(Graphics g, int xDraw, int yDraw) {
        Graphics2D g2 = (Graphics2D) g;
        
        BasicStroke wideStroke = new BasicStroke(2.0f);
        g2.setStroke(wideStroke);
        g2.setColor(Color.red);
        
        g2.drawLine(xDraw-8, yDraw+7, xDraw+8, yDraw+7);
        g2.drawLine(xDraw-8, yDraw+7, xDraw, yDraw-11);
        g2.drawLine(xDraw+8, yDraw+7, xDraw, yDraw-11);
        
        BasicStroke stroke = new BasicStroke(1.0f);
        g2.setStroke(stroke);
    }

    private void drawDepot(Graphics g, int xDraw, int yDraw, int iconSlot) {
        Color savedColor = g.getColor();

        g.setColor(Color.ORANGE);

        xDraw = 4 + xDraw + 12 * iconSlot;
        yDraw = yDraw + 12;
        g.fillRect(xDraw + 5, yDraw - 10, 5, 5);
        g.fillRect(xDraw + 2, yDraw - 5, 10, 5);

        g.setColor(savedColor);
    }

    private void drawFortification(Graphics g, int xDraw, int yDraw, int iconSlot) {
        Color savedColor = g.getColor();

        g.setColor(new Color(200, 200, 200));

        xDraw = 4 + xDraw + 12 * iconSlot;
        yDraw = yDraw + 12;
        
        Graphics2D g2d = (Graphics2D)g;
        g2d.setStroke(wideStroke3f);
        g2d.drawRect(xDraw + 4, yDraw - 10, 10, 8);
        
        g2d.setStroke(stroke1f);
        g.setColor(savedColor);
    }

    private void drawFactory(Graphics g, int xDraw, int yDraw, int iconSlot) {
        Color savedColor = g.getColor();

        g.setColor(Color.white);

        xDraw = 4 + xDraw + 12 * iconSlot;
        yDraw = yDraw + 12;
        g.fillRect(xDraw + 4, yDraw - 10, 2, 10);
        g.fillRect(xDraw + 8, yDraw - 10, 2, 10);
        g.fillRect(xDraw + 6, yDraw - 5, 7, 5);

        g.setColor(savedColor);
    }

    private void drawWarship(Graphics g, int xDraw, int yDraw, int iconSlot) {
        // TODO
    }

    // Public Methods ----------------------------------------------------------
    public void paintComponent(Graphics g) {
        super.paintComponent(g);

        panelWidth = this.getWidth();
        panelHeight = this.getHeight();

//        try{
//            // Create the bufferedImage for the background
//            mainImageBuffer = new BufferedImage(panelWidth + 800, panelHeight +800, BufferedImage.TYPE_INT_ARGB);
//        }
//        catch(OutOfMemoryError e) {
//            e.printStackTrace();
//            return;
//        }
//        Graphics gMain = mainImageBuffer.getGraphics();
//        renderMap(gMain);
//        g.drawImage(mainImageBuffer, 400, 400, panelWidth+400, panelHeight+400, null);
        renderMap(g);
    }

    public int getZoom() {
        return zoom;
    }

    public void setZoom(int zoom) {
        this.zoom = zoom;
        this.repaint();
    }

    public void setSelectedFaction(Faction selectedFaction) {
        this.selectedFaction = selectedFaction;
    }

    public boolean isMoveMode() {
        return moveMode;
    }

    public void setMoveMode(boolean panelInMoveMode) {
        this.moveMode = panelInMoveMode;
    }

    public StarSystem getSourceSystem() {
        return sourceSystem;
    }

    public void setSourceSystem(StarSystem sourceSystem) {
        this.sourceSystem = sourceSystem;
    }

    public Set<StarSystem> getCadidateDestinations() {
        return candidateDestinations;
    }

    public void setCadidateDestinations(Set<StarSystem> cadidateDestinations) {
        this.candidateDestinations.clear();
        this.candidateDestinations.addAll(cadidateDestinations);
    }

    public void setAssaultMode(boolean b) {
        this.assaultMode = b;
    }

    public boolean isAssaultMode() {
        return assaultMode;
    }

    // code taken from http://www.jhlabs.com/java/java2d/strokes/
    public class CompositeStroke implements Stroke {
        private Stroke stroke1, stroke2;

        public CompositeStroke(Stroke stroke1, Stroke stroke2) {
            this.stroke1 = stroke1;
            this.stroke2 = stroke2;
        }

        public Shape createStrokedShape(Shape shape) {
            return stroke2.createStrokedShape(stroke1.createStrokedShape(shape));
        }
    }
}
